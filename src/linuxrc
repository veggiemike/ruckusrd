#!/bin/ash
#
# Copyright 2012-2020 Michael D Labriola <michael.d.labriola@gmail.com>
#
# Licensed under the GPLv3. See the file COPYING for details. 
#
# This initramfs /init script is a derivative of the one embedded in mayflower
# (flexible mkinitrd replacement used originally by fedora's livecd-creator,
# David Zeuthen <davidz@redhat.com>).
#
# It's been largely rewritten (multiple times now) to be used as the initramfs
# /init script for a mkinitrd replacement that can be used on embedded systems,
# flash drives, live CDs, and normal desktop Linux systems.  See the file
# README for details.
#
# NOTE: At the moment, and this might change, we're not loading KMS video
#       drivers in here.  I was planning on doing just that, but I couldn't
#       quite get things working the way I wanted.
#
#       For example, using nouveau on one of our old dual-Xeons, even if the
#       very fist line of the script is 'modprobe nouveau', you don't get
#       penguin logos.  However, if nouveau is actually built into the kernel,
#       you get penguins a split second after booting starts, but you also get a
#       big white box that obscures some of the output.  So the best way to
#       ensure you get the penguin logos appears to still be to set
#       vga=something to initialize the vga framebuffer for a few seconds before
#       the KMS video driver gets loaded.  And If we do that and then load the
#       KMS driver in the initrd, you get two modesets within a 1-2 second
#       window... which just looks strange.
#
#       If we ever decide to play with plymouth or some other nice splash screen
#       utility, we might want to revisit this and just ditch the penguin logos
#       (although I kinda like being able to see right off the bat how many CPUs
#       have been detected).
#
# ---- BUSYBOX COMPAT NOTE ----
# So far, this script uses the following non-basic features that I should
# double-check for busybox applet compatibility moving forward:
#
# - sed -i (yes!)
# - bash ${param#word} and ${param//pattern/string} expansions (yes and yes!)
# - bash trap and set -e (maybe... testing now)
# - bash $() command subst (yes!)
# - bash {} globbing (e.g., cp foo{,bak}) (NOPE)
# - bash var+= (NOPE)


. /ruckusrd.conf


decho()
{
    if [ "$quiet" != "1" ]; then
        echo "$*"
    fi
}


# waits up to $1 seconds for $2 symlink to get created by udev.  if it takes
# longer than that, something is wrong, but maybe the user can fix it.
#
# NOTE: Adds device-mapper device name responsible for the required evice to
#       $dmneeded prior to returning.
#
wait_for_udev_symlink()
{
    x=$1
    dev=$2
    msg="waiting up to $x seconds for $dev symlink..."
    while [ ! -e $dev -a "$x" != "0" ]; do
        if [ -n "$msg" ]; then
            echo -n $msg
            msg=""
        else
            echo -n "."
        fi
        x=$(($x-1))
        # just in case we need to activate LVM on a freshly plugged device
        # (e.g., USB that was a bit slow to register
        vgchange -a y --quiet --quiet
        sleep 1
    done

    # NOTE: At this point, either the symlink exists OR our waitloop timed out.
    #       We'll give the user a chance to manually create the symlink if it's
    #       missing.
    #
    if [ -b $dev ] ; then
        [ -z "$msg" ] && echo " done"
        decho "$dev symlink exists"
    else
        echo
        echo
        echo "--------------------------------------"
        echo "WARNING: Cannot find device for $dev!"
        echo "--------------------------------------"
        echo
        echo "Create symlink $dev and then exit this shell to continue"
        echo "the boot sequence."
        echo
        bash
    fi

    dmneeded="$dmneeded $(dmsetup info -c --noheadings -o name $dev 2>/dev/null || echo)"
}


emergency_shell()
{
    echo "Bug in initramfs /init detected. Dropping to a shell. Good luck!"
    echo
    bash
}


modprobe()
{
    grep -q $1.ko /lib/modules/$(uname -r)/modules.builtin || /sbin/modprobe $*
}


autoload_fs_module()
{
    eval $(blkid $1 | sed 's|.*: ||')
    [ -n "$TYPE" ] && modprobe $TYPE
}


# This method creates udev rules such that we end up with a /dev/$1 symlink
# that points to the device specified by $2, which can be CDLABEL, LABEL, UUID,
# or an actual device name (e.g., /dev/sda1, /dev/md0, /dev/mapper/vg0_lv1).
#
# NOTE: This method modifies the following important global variables:
#
#       thingtomount: argument to be mounted for root filesys
#
generate_udev_rules()
{
    name=$1
    str=$2

    # blkid commands
    #
    # FIXME: ditch this and use builtin blkid!
    #
    # IMPORT{builtin}="blkid"
    # then just use ENV{ID_FS_UUID_ENC} ENV{ID_FS_LABEL_ENC}
    #
    #get_label="/sbin/blkid -o value -s LABEL"
    #get_uuid="/sbin/blkid -o value -s UUID"

    # FIXME: probably want to entirely rewrite these rules for eudev (upstream
    #        220).
    #
    case $str in
        # NOTE: While CDLABEL and LABEL could use the same udev rule, we use
        #       the different str to differentiate later on (e.g., for fsck).
        #
        CDLABEL=*)
            # NOTE: we're assuming SCSI device nodes here, now that SATA, PATA,
            #       USB, and SCSI should all be using them.
            #
            # FIXME: can we just use the cdrom.rule's ID_CDROM=1?  looks like
            #        no...
            #
            CDLABEL=${str#CDLABEL=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", KERNEL=="sr[0-9]*", ENV{ID_FS_LABEL_ENC}=="$CDLABEL", SYMLINK+="$name"
EOF
            decho "Added udev rule for CDLABEL=='$CDLABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        LABEL=*)
            LABEL=${str#LABEL=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", KERNEL!="sr[0-9]", ENV{ID_FS_LABEL_ENC}=="$LABEL", SYMLINK+="$name"
EOF
            decho "Added udev rule for LABEL=='$LABEL'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        UUID=*)
            UUID=${str#UUID=}
            cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules
SUBSYSTEM=="block", ENV{ID_FS_UUID_ENC}=="$UUID", SYMLINK+="$name"
EOF
            decho "Added udev rule for UUID=='$UUID'"
            if [ "$name" = "root" ]; then
                thingtomount=/dev/root
            fi
            ;;
        /dev/*)
            ln -fs $str /dev/$name
            if [ "$name" = "root" ]; then
                thingtomount=$str
            fi
            ;;
        *)
            if [ "$name" = "root" ]; then
                thingtomount=$str
            fi
            ;;
    esac
}


trap "emergency_shell" 0 2

# exit immediately if a command fails
#
# FIXME: does this work in ash?
#
set -e

PATH=/sbin:/bin

exec < /dev/console > /dev/console 2>&1

echo "initramfs created with RuckusRD v$VERSION"

# mount devtmpfs for /dev
mount -n -t devtmpfs -o mode=0755 devtmpfs /dev || \
    ( echo "is CONFIG_DEVTMPFS enabled in your kernel?"; emergency_shell )

# mount virtual filesystems
mount -n -t proc proc /proc
mount -n -t sysfs sysfs /sys

# create /etc/mtab symlink
ln -fs /proc/mounts /etc/mtab

# ensure hotplog script is disabled even if CONFIG_UEVENT_HELPER is enabled
if [ -f /proc/sys/kernel/hotplug ]; then
    echo "" > /proc/sys/kernel/hotplug
fi


# Declare all variables here.. mostly for housekeeping
init="/sbin/init"
root="/dev/something"
root_rw=""
root_true_rw="ro"
rootflags=""
rootfstype="auto"
to_ram=""
shell="" # right after booting, almost useless
shell2="" # after waiting for harddrives, udev, lvm work, etc, just prior to mounting rootfs
shell3="" # prior to doing sqsh_layer magic (but after moving /sysroot to /tmproot)
shell4="" # just prior to mounting final overlayfs
maint="" # just before switch_root and handover to init
hoststamp=""
quiet=0
sqsh_layers=""
sqsh_layerdev=""
sqsh_layerdir="/tmproot"
sqsh_layerdir_rel=""
ram_layer=""

# Parse kernel commandline options
#
# NOTE: By default, when this script hands off control the the underlying
#       root filesystem's init process, the rootfs will be mounted ro.  This
#       behavior can be overriden by passing 'rw' on the kernel command
#       line.
#
# NOTE: rootfstype, rootflags are only applied when mounting the specified root
#       device.  in other words, they are not used when mounting the derivative
#       devices created when we load rootfs into RAM.
for o in `cat /proc/cmdline` ; do
    case $o in 
    init=*)
        init=${o#init=}
        ;;
    quiet)
        quiet=1
        ;;
    to_ram)
        to_ram=1
	;;
    shell)
        shell=1
        ;;
    shell2)
        shell2=1
        ;;
    shell3)
        shell3=1
        ;;
    shell4)
        shell4=1
        ;;
    maint)
	maint=1
	;;
    rw)
        root_rw=1
        ;;
    root_true_rw)
        root_true_rw="rw"
        ;;
    hoststamp)
        hoststamp=1
        ;;
    blacklist=*)
        blacklist=${o#blacklist=}
        echo "blacklist $blacklist" >> /etc/modprobe.conf
        ;;
    root=*)
        root=${o#root=}
        ;;
    rootflags=*)
        rootflags=${o#rootflags=}
        ;;
    rootfstype=*)
        rootfstype=${o#rootfstype=}
        ;;
    sqsh_layers=*)
        sqsh_layers=${o#sqsh_layers=}
        # make layers space-delimited for iterating
        sqsh_layers_ws=${sqsh_layers//:/ }
        ;;
    sqsh_layerdev=*)
        sqsh_layerdev=${o#sqsh_layerdev=}
        sqsh_layerdir=/sqsh_layerdev
        ;;
    sqsh_layerdir=*)
        sqsh_layerdir_rel=${o#sqsh_layerdir=}
        ;;
    ram_layer=*)
        ram_layer=${o#ram_layer=}
        ;;
    *)
        # NOTE: putting "loop.max_loop=16" in cmdline would cause "options loop
        #       max_loop=16" to get written in modprobe.conf...
        m=$(echo $o |cut -s -d . -f 1)
        opt=$(echo $o |cut -s -d . -f 2-)
        if [ -z "$m" -o -z "$opt" ]; then
          continue
        fi
        p=$(echo $opt |cut -s -d = -f 1)
        v=$(echo $opt |cut -s -d = -f 2-)
        if [ -z "$p" -o -z "$v" ]; then
          continue
        fi
        echo "options $m $p=$v" >> /etc/modprobe.conf
        ;;
    esac
done

# if user provided sqsh_layerdir, append it to the device mountpoint
if [ -n "$sqsh_layerdir_rel" ]; then
    sqsh_layerdir=$sqsh_layerdir/$sqsh_layerdir_rel
fi

decho "kernel commandline: `cat /proc/cmdline`"
decho "init=$init"
decho "root=$root"
decho "root_rw=$root_rw"
decho "root_true_rw=$root_true_rw"
decho "rootflags=$rootflags"
decho "rootfstype=$rootfstype"
decho "to_ram=$to_ram"
decho "shell=$shell"
decho "shell2=$shell2"
decho "shell3=$shell3"
decho "shell4=$shell4"
decho "maint=$maint"
decho "hoststamp=$hoststamp"
decho "sqsh_layers=$sqsh_layers"
decho "sqsh_layerdev=$sqsh_layerdev"
decho "sqsh_layerdir=$sqsh_layerdir"
decho "sqsh_layerdir_rel=$sqsh_layerdir_rel"
decho "ram_layer=$ram_layer"

if [ -n "$shell" ]; then
    echo "Dropping directly into shell, as requested.  Enjoy!"
    echo
    bash
fi

# load loop module (if not built-in)
#
# NOTE: It doesn't look like losetup triggers an auto-load of the loop module.
#
# FIXME: The CentOS7 kernel has CONFIG_BLK_DEV_LOOP_MIN_COUNT=0... which means
#        modprobing doesn't create any device nodes.  we can either figure out
#        the right way to do this (via loop-control?) or modprobe loop
#        max_loop=32.
#
#        maybe loop-control will autoprobe?
#
#        So, looks like "real" losetup will open /dev/loop-control (which
#        probably triggers modprobe of loop) and does some IOCTLs to create
#        loop device nodes.  I'm guessing the busybox version assumes they're
#        already there.
#
modprobe loop max_loop=32

echo -n "determining what to mount... "

cat <<EOF > etc/udev/rules.d/99-ruckusrd.rules
ACTION!="add|change", GOTO="ruckusrd_end"
SUBSYSTEM!="block", GOTO="ruckusrd_end"
IMPORT{builtin}="blkid"

EOF

generate_udev_rules root $root
[ -n "$sqsh_layerdev" ] && generate_udev_rules sqsh_layerdev $sqsh_layerdev

cat <<EOF >> etc/udev/rules.d/99-ruckusrd.rules

LABEL="ruckusrd_end"
EOF

echo "$thingtomount"

# prep udev hwdb
go="/sbin/udevadm"
[ "$quiet" != "1" ] && go="$go --debug"
go="$go hwdb --update"
decho $go
eval $go

decho "starting udevd"
/sbin/udevd --daemon --resolve-names=never

# tell udevd to start processing its queue
#
# NOTE: I used to just trigger and settle...  LFS does these 3 triggers and
#       then conditionally settles.  Not 100% sure of the rationale, but I'll
#       follow LFS on this one.
#
/sbin/udevadm trigger --action=add --type=subsystems
/sbin/udevadm trigger --action=add --type=devices
/sbin/udevadm trigger --action=change --type=devices

# wait for at least one harddisk to be handled by udev
#
# NOTE: A full blown settle can take longer than I'd like (~10 seconds).  We
#       can tell udevadm to STOP waiting as soon as a particular device exists,
#       but I can't specify more than one.  So we don't call settle, we loop on
#       our own waiting for /dev/sda or /dev/nvme0n1 (or anything else I decide
#       to wait on in the future).
#
#/sbin/udevadm settle --exit-if-exists=/dev/sda
#
x=10
msg="waiting up to $x seconds for at least one hdd to appear..."
while [ ! -e /dev/sda -a ! -e /dev/nvme0n1 -a ! -e /dev/xvda -a "$x" != "0" ]; do
    if [ -n "$msg" ]; then
        echo -n $msg
        msg=""
    else
        echo -n "."
    fi
    x=$(($x-1))
    sleep 1
done
if [ -z "$msg" ]; then
    echo -n "."
    # and one more second just to be safe
    sleep 1
    echo " done"
fi

# activate LVM
#
# NOTE: We activate ALL logical volumes here.  Once our udev rules have created
#       the /dev symlinks we need, we deactivate all the logvols that weren't
#       needed for booting.  Some systems (e.g., fedora and it's cousins) like
#       to hang for 90 seconds flailing around w/ already activated logvols
#       unless we do this.
#
decho "activating LVM"
vgchange -a y --quiet --quiet

# wait for udev symlinks to get created
dmneeded=""
wait_for_udev_symlink 30 /dev/root
root_true=`readlink /dev/root`
[ -n "$sqsh_layerdev" ] && wait_for_udev_symlink 30 /dev/sqsh_layerdev

# autoload filesystem modules if needed
autoload_fs_module /dev/root
rootfstype=$TYPE
if [ -n "$sqsh_layerdev" ]; then
    autoload_fs_module /dev/sqsh_layerdev
    sqshfstype=$TYPE
fi

# deactivate unneeded logvols
#
# FIXME: what if i just deactivate all after mounting /sysroot... will it
#        politely refuse to deactive mounted logvols?
#
decho "deactivating unneeded LVM (dmneeded='$dmneeded')"
vgchange -a n --quiet --quiet
for x in $dmneeded; do
    lvchange -a y /dev/mapper/$x --quiet --quiet
done

# run fsck on root dev
#
# NOTE: The root dev becomes impossible to unmount (and thus, impossible to
#       safely fsck) after we pass control over to the host os (unless we load
#       the whole image into RAM).
#
# NOTE: While we do care if this fails, we don't really want a failure to keep
#       the system from booting, especially since an exit status of 1 indicates
#       that fsck found AND SUCCESSFULLY FIXED some errors.
#
# NOTE: Obviously, running fsck on CD/DVD would be dumb.
#
# FIXME: We should really do better fsck error checking (see fsck(8) for exit
#        codes).
#
# FIXME: should we fsck sqsh_layerdev too?  same rationale applies... probably
#        can't umount once we've put things together (unless to_ram?).
#
if ! (echo $root | grep -q CDLABEL); then
    go="fsck -TC $thingtomount"
    decho $go
    eval $go || echo "WARNING: fsck of rootdev exited non-zero"
fi


# shell breakpoint #2
if [ -n "$shell2" ]; then
    echo "Dropping into shell prior to mounting rootfs, as requested.  Enjoy!"
    echo
    bash
fi


mountoptions=" -o ro"
if [ -n "$rootflags" ]; then
    mountoptions="$mountoptions,$rootflags"
fi

go="mount -t $rootfstype $mountoptions $thingtomount /sysroot"
decho $go
eval $go
RES=$?

if [ "$RES" != "0" ] ; then
    echo "---------------------------------"
    echo "WARNING: Cannot mount rootfs!"
    echo "---------------------------------"
    echo
    echo "Dropping to a shell. "
    echo "Mount rootfs at /sysroot and exit shell to continue. Good luck!"
    echo
    bash
fi

# look for sqsh_layerdev
if [ -h /dev/sqsh_layerdev ]; then
    # NOTE: rootfstype and mountoptions do NOT follow the rootfs rules
    go="mkdir -p /sqsh_layerdev && mount -t $sqshfstype -o ro /dev/sqsh_layerdev /sqsh_layerdev"
    decho $go
    eval $go
fi

# only pass kernel command line if we're launching /sbin/init
if [ "$init" == "/sbin/init" ] ; then
    initargs=$(cat /proc/cmdline)
else
    initargs=""
fi

# do prep for squashfs magic common to both old device-mapper and new overlayfs
# implementations
if [ -n "$sqsh_layers" ]; then
    decho "doing common squashfs prep"

    ln -s $root_true /dev/root-true

    # move /sysroot out of the way so we can still access it
    mkdir /tmproot
    decho "moving /sysroot to /tmproot"
    mount --move /sysroot /tmproot
fi


# shell breakpoint #3
if [ -n "$shell3" ]; then
    echo "Dropping into shell prior to sqsh_layer magic, as requested.  Enjoy!"
    echo
    bash
fi


# squashfs magic time
if [ -n "$sqsh_layers" ]; then
    # do new OverlayFS based stuff
    decho "setting up OverlayFS squashfs layers"

    # copy to ram if requested
    #
    # NOTE: We copy them to RAM, but then move the dir they're in to
    #       /mnt/sqsh_layerdev later on so it's available via a visible filesys
    #       for future usage (e.g., creating virtual machines, installing).
    #
    if [ -n "$to_ram" ]; then
        echo -n "Copying squashfs layer(s) to RAM... "
        mkdir -p /sqsh_layerdev
        decho ""
        go="cp -a"
        [ "$quiet" != "1" ] && go="$go -v"
        # FIXME: this is assuming all layers are on sqsh_layerdev, which is no
        #        longer true for checkpointed upper-dir stuff being added...
        #        that stuff wouldn't make sense to load into ram anyways, but
        #        still... it's worth mentioning or putting some corrective code
        #        here
        for x in $sqsh_layers_ws; do
            go="$go $sqsh_layerdir/$x.sqsh"
        done
        go="$go /sqsh_layerdev"
        decho $go
        eval $go
	echo "done"
        sqsh_layerdir=/sqsh_layerdev
    fi

    # mount individual layers
    #
    # NOTE: We create /dev symlinks here to disguise the loopback device.
    #       W/out it, some systems attempt to unmount loop devices prior to
    #       other filesystems, which leads to problems. (also, it's helpful for
    #       the user to see in df output)
    #
    #       we won't have to worry pre-switchroot paths being incorrect once we
    #       swithcroot.
    #
    top=
    for x in $sqsh_layers_ws; do
        # check to see if layer is a true sqsh layer or a checkpointed upper
        # layer.
        loopdev=$(losetup -f)
        losetup $loopdev $sqsh_layerdir/$x.sqsh
        ln -s $loopdev /dev/sqsh_layer-$x
        mkdir -p /sqsh_layer-$x
        go="mount -o ro /dev/sqsh_layer-$x /sqsh_layer-$x"
        decho $go
        eval $go
        # mount overlay combining lower layers, if needed
        #
        # NOTE: This is to avoid problems w/ overlayfs lower layers (i.e., if
        #       you just use an old 'upper', it's missing the old 'work', which
        #       causes breakage w/ xino and other overlayfs features)
        #
        #       The idea here, is to mount each lower layer as an independent
        #       overlay mount, with it's own upper and work dirs.  We're
        #       basically taking the nesting of lower layers out and
        #       implementing it ourselves.
        #
        # FIXME: how are these middle layers created...?  are we assuming the
        #        creation of blarg.sqsh such that it contains the old upper and
        #        work dirs?  or are we going to just keep the old upper and
        #        work dirs IN the actual ext4 root-true upper filesystem?  in
        #        other words, do we really just have a bottommost sqsh with a
        #        bunch of named upper dirs int he actual ext4 filesystem?
        #
        #        i'd like to go for broke and assume the creation of blarg.sqsh
        #        containing upper and work... that keeps root-true the
        #        cleanest, and makes middle layers more like bottom layers...
        #        but that means we'll have to do something extra when using
        #        ram_layer for non-retentive upper layer (e.g., shenanigans?
        #        or create a sqsh from the old upper temporarily?)
        #
        if [ -n "$top" ]; then
            mkdir -p /sqsh_layer-$x-overlay
            overlayflags=lowerdir=$top,upperdir=/sqsh_layer-$x/upper,workdir=/sqsh_layer-$x/work
            go="mount -t overlay -o ro,$overlayflags $x-midlayer /sqsh_layer-$x-overlay"
            decho $go
            eval $go
            top=/sqsh_layer-$x-overlay
        else
            top=/sqsh_layer-$x
        fi
    done

    # create ram layer if requested
    if [ -n "$ram_layer" ]; then
        decho "creating ram_layer w/ size=$ram_layer"
        mkdir -p /upper
        mount -t tmpfs -o size=$ram_layer ram_layer /upper
        mkdir -p /upper/upper /upper/work
        decho "converting retentive upper to non-retentive lower layer"
        # FIXME: if we do this, we will NOT be able to completely unmount the
        #        orignal root device w/out doing some extra shenanigans...
        mkdir -p /sqsh_layer-upper
        # FIXME: are we going to run into the multiple lower layer problems
        #        (e.g., falling back to index=off,nfs_export=off) if we do
        #        this?
        #
        #        testing this out looks like "probably, yes".  i get wonky
        #        errors from systemd that can mostly be worked around... but
        #        clearly something is amiss.  pretty sure xino is not getting
        #        enabled.
        #
        go="mount -o ro,bind /tmproot/upper/upper /sqsh_layer-upper"
        decho $go
        eval $go
        mkdir -p /sqsh_layer-upper-overlay
        overlayflags=lowerdir=$top,upperdir=/sqsh_layer-upper/upper,workdir=/sqsh_layer-upper/work
        go="mount -t overlay -o ro,$overlayflags upper-midlayer /sqsh_layer-upper-overlay"
        decho $go
        eval $go
        top=/sqsh_layer-upper-overlay
        sqsh_layers=upper:$sqsh_layers
        sqsh_layers_ws="upper $sqsh_layers_ws"
        upper=upper
    else
        # need to remount rootfs rw so we can write into upper layer
        decho "remounting /tmproot rw"
        mount -o remount,rw /tmproot
        mkdir -p /tmproot/upper/upper /tmproot/upper/work
        upper=/tmproot/upper
        # if we're not using ram_layer, we cannot remount sysroot ro later on,
        # so we must change this flag to rw
        root_true_rw=rw
    fi


    # shell breakpoint #4
    if [ -n "$shell4" ]; then
        echo "Dropping into shell prior to final overlayfs mount, as requested.  Enjoy!"
        echo
        bash
    fi


    # mount the merged filesystem
    #
    # NOTE: We've setup intermediate overlay mounts for nested lower layers, so
    #       this is just us layer the topmost lower layer with our upper.
    #
    decho "mounting overlayfs at /sysroot"
    #lower=/sqsh_layer-${sqsh_layers//:/:/sqsh_layer-}
    lower=$top
    overlayflags=lowerdir=$lower,upperdir=$upper/upper,workdir=$upper/work
    #decho "lower: $lower"
    #decho "upper: $upper"
    go="mount -t overlay -o $overlayflags rootfs /sysroot"
    decho $go
    eval $go

    # this leaves us with /boot containing the merged contents of the layers...
    # but the ACTUAL boot files will end up living in /mnt/root-true/boot/...
    # which is confusing.  so lets bind-mount that to /boot.
    #
    # NOTE: we do this unless we're booting to_ram, in which case the boot
    #       files are no longer mounted anywhere once the system boots.
    #
    # FIXME: if to_ram, consider removing /boot (or it's contents) to make it
    #        super obvious that whatever's in /boot wasn't actually used to
    #        boot.
    #
    #        if we were to do that, we'd want to only do it if to_ram AND
    #        ram_layer, otherwise we'll be recording that deletion in upper
    #        (remember, we've got a rw overlay backed by /mnt/root-true/upper).
    #
    # FIXME: this might get wonky on EFI systems that use an ESP of /boot/efi
    #        (ubuntu, maybe redhat)...  is the ESP gets mounted by the actual
    #        host system after handoff (via /etc/fstab), it *should* happily
    #        mount the ESP on top of our bindmounted /boot.
    #
    if [ -z "$to_ram" ]; then
        if [ -n "`find /tmproot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel directly in /tmproot, so it's probably a /boot
            # partition.  bind mount it as such.
            decho "bind mounting /tmproot to /sysroot/boot"
            mount --bind /tmproot /sysroot/boot
        elif [ -n "`find /tmproot/boot -maxdepth 1 -name vmlinuz\* 2>/dev/null`" ]; then
            # there's a kernel inside a boot dir inside /tmproot, bind mount
            # it!
            decho "bind mounting /tmproot/boot to /sysroot/boot"
            mount --bind /tmproot/boot /sysroot/boot
        else
            # odd... couldn't find a kernel...?
            #
            # NOTE: This might be totally normal.  Booting UEFI, for example,
            #       could have the kernel and other support files included on
            #       the ESP, which we don't have mounted in here.  If that's
            #       the case, the host sytem will mount the ESP via its fstab
            #       normally.
            #
            decho "couldn't find /boot tree to bind mount, but might be fine"
        fi
    fi
fi

# do extra squashfs magic common to both old device-mapper and new overlayfs
# implementations
if [ -n "$sqsh_layers" ]; then
    decho "doing common squashfs finalization"

    # copy over module options
    #
    # NOTE: we really want to do this. without it there's no way to update
    #       modeprobe.conf before modules get loaded... can't exactly edit
    #       modprobe.conf and reboot, as our changes get lost.  (e.g., module
    #       blacklisting or module options on kernel command line)
    #
    # NOTE: but we don't want this if sqsh_layers w/out ram_overlay
    #
    if [ -z "$ram_layer" ]; then
        [ -f /etc/modprobe.conf ] && cat /etc/modprobe.conf >> /sysroot/etc/modprobe.conf
    fi

    # append a timestamp to system hostname if configured
    if [ -n "$hoststamp" ]; then
        stamp=`date +%s`
        decho "appending timestamp to hostname: $stamp"
        if [ -f /sysroot/etc/hostname ]; then
            # systemd
            HOSTNAME=$(cat /sysroot/etc/hostname)-$stamp
            echo $HOSTNAME > /sysroot/etc/hostname
        elif [ -f /sysroot/etc/sysconfig/network ]; then
            # old redhat-ish sysvinit
            . /sysroot/etc/sysconfig/network
            [ -n "$HOSTNAME" ] || break
            for x in /etc/sysconfig/network /etc/hosts; do
                sed -i "s|\($HOSTNAME\)|\1-$stamp|" /sysroot/$x
            done
        fi
    fi

    # get ready to fix mtab
    #
    # NOTE: We can't just forge /etc/mtab at this point, because some systems
    #       sysinit scripts purge old cruft out of that file on the assumption
    #       that the initrd has ONLY mounted /.  So instead, we'll append a
    #       scriptlet that does the forging into rc.local.
    #
    # NOTE: All this mtab forging is completely unneeded on distros
    #       that use a symlink to /proc/mounts for mtab.
    #
    # FIXME: At this point, is seems like a safe assumption that all
    #        distros still have rc.local for backwards
    #        compatibility...  but you know how assumptions work....
    #        at some point, we may need to create a systemd service
    #        for this.
    #
    if [ -h /sysroot/etc/mtab ]; then
	RCLOCAL=
    else
	# use /etc/rc.d/rc.local if it exists, otherwise just use /etc/rc.local
	if [ -f /sysroot/etc/rc.d/rc.local ]; then
	    RCLOCAL=/etc/rc.d/rc.local
	else
	    RCLOCAL=/etc/rc.local
	fi
	# create rc.local if needed
	if [ ! -x /sysroot/$RCLOCAL ]; then
	    touch /sysroot/$RCLOCAL
	    chmod +x /sysroot/$RCLOCAL
	fi
	cp /sysroot/$RCLOCAL /sysroot/$RCLOCAL.ruckusrdbak
    fi
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
# --- begin ruckusrd appendage ---
EOF
    fi

    # move /sqsh_layerdev into /sysroot
    if [ -h /dev/sqsh_layerdev ]; then
        decho "moving /sqsh_layerdev to /sysroot/mnt/"
	mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --move /sqsh_layerdev /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto ro 0 0 >> /etc/mtab
EOF
	fi
    fi

    # move individual layer mounts into /sysroot
    for x in $sqsh_layers_ws; do
        decho "moving /sqsh_layer-$x to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/sqsh_layer-$x
        mount --move /sqsh_layer-$x /sysroot/mnt/sqsh_layer-$x
        # NOTE: We don't forge mtab entries for these because it just clutters
        #       df output needlessly.
    done

    # move ram layer if needed
    if [ -n "$ram_layer" ]; then
        decho "moving /upper to /sysroot/mnt/"
        mkdir -p /sysroot/mnt/upper
        mount --move /upper /sysroot/mnt/upper
        # NOTE: We don't forge an mtab entry for this because overlayfs is
        #       smart enough to always show the stats of upperdir in df output.
    fi

    # Move the old sysroot into the new one, if needed.
    #
    # NOTE: root-true is left mounted unless to_ram was specified, in which
    #       case it is unmounted but the mountpoint is configured in /etc/fstab
    #       for easy re-mounting.
    #
    mkdir -p /sysroot/mnt/root-true
    if [ -z "$to_ram" ]; then
        decho "moving /tmproot to /sysroot/mnt/root-true"
	mount --move /tmproot /sysroot/mnt/root-true
        # NOTE: I considered not adding this mtab entry when root-true is being
        #       used for upperdir, because you essentially get root-true's
        #       stats for both rootfs and root-true in df...  but that hides
        #       the fact that our real root device (i.e., boot device) is still
        #       mounted at /mnt/root-true.  Unlike the layers themselves, this
        #       is important to know (e.g., so you can go muck with the
        #       bootloader config).
        #
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/root-true /mnt/root-true auto $root_true_rw 0 0 >> /etc/mtab
EOF
	fi
    else
        # setup easy mounting of /dev/root-true
        #
        # NOTE: we let the fstab injection fail to allow users to put new
        #       copies of fstab in the conf dir... which might overwrite
        #       /sysroot/etc/fstab with a symlink that's broken until we hand
        #       off control via switch_root.
        #
        echo "" >> /sysroot/etc/fstab || echo -n
        echo "/dev/root-true /mnt/root-true auto noauto,$root_true_rw 0 0" >> /sysroot/etc/fstab || echo -n

        # unmount it (so we can eject removable media)
        decho "unmounting /tmproot"
        umount /tmproot

        # we copied sqsh_layers into RAM.  make them visible in the baby
        # filesystem at /mnt/sqsh_layerdev
        mkdir -p /sysroot/mnt/sqsh_layerdev
        mount --bind $sqsh_layerdir /sysroot/mnt/sqsh_layerdev
	if [ -n "$RCLOCAL" ]; then
	    cat <<EOF >> /sysroot/$RCLOCAL
echo /dev/sqsh_layerdev /mnt/sqsh_layerdev auto rw 0 0 >> /etc/mtab
EOF
	fi
    fi

    # add some debug output
    if [ "$quiet" != "1" ] && [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
echo ---------------
df -h
echo ---------------
mount
echo ---------------
EOF
    fi

    # make sure rc.local doesn't grow into a giant mess
    #
    # NOTE: We made a copy of rc.local before we started appending to it.  This
    #       makes rc.local restore itself to its previous state once it's done
    #       executing our extra lines.
    #
    if [ -n "$RCLOCAL" ]; then
	cat <<EOF >> /sysroot/$RCLOCAL
mv $RCLOCAL.ruckusrdbak $RCLOCAL
EOF
    fi

    # fix unmount chicken-and-the-egg problem
    #
    # NOTE: If not to_ram, the device(s) required to assemble the rootfs end up
    #       getting moved to mountpoints on top of the rootfs in the final
    #       system.  This leaves us with a can't unmount /mnt/sqsh_layerdev
    #       w/out unmounting / first dilemma leading to potential errors and
    #       time-outs during shutdown.  The easy fix is to lazy-unmount the
    #       troublesome devices.  The messy part is how to do it w/out making
    #       assumptions about the system being booted.  We have to register
    #       some sort of script to execute at shutdown, after mostly everything
    #       has finished, but before the system tries to unmount its rootfs.
    #
    # FIXME: figure out how to make this not depend on SysV-Init style scripts,
    #        and the naming/ordering of the host systems shutdown/halt scripts.
    #
    #        i made a systemd unit for gkrellmd at cah, it was
    #        simple...  just need to figure out how to propperly
    #        detect systemd vs sysvinit
    #
    if [ -z "$to_ram" ]; then
        cat <<EOF > /sysroot/etc/init.d/ruckusrd_umount
#!/bin/sh

# quietly umount rootfs dependencies that we left mounted on top of rootfs, so
# that we can umount / eventually.

umount -l /boot 2>/dev/null

mount -o remount,ro /mnt/root-true 2>/dev/null
umount -l /mnt/root-true 2>/dev/null

mount -o remount,ro /mnt/sqsh_layerdev 2>/dev/null
umount -l /mnt/sqsh_layerdev 2>/dev/null

EOF
        for x in $sqsh_layers_ws; do
            cat <<EOF >> /sysroot/etc/init.d/ruckusrd_umount
umount -l /mnt/sqsh_layer-$x 2>/dev/null
EOF
        done

        chmod +x /sysroot/etc/init.d/ruckusrd_umount
        ln -fs ../init.d/ruckusrd_umount /sysroot/etc/rc0.d/S00ruckusrd_halt
        ln -fs ../init.d/ruckusrd_umount /sysroot/etc/rc6.d/S00ruckusrd_reboot
    fi

    # and finally, remount /sysroot read-only because most/all systems expect /
    # to be mounted ro prior to their init systems taking over.
    mount -o remount,ro /sysroot
fi


# remount final root dev rw if requested
[ -n "$root_rw" ] && mount -o remount,rw /sysroot

if [ -n "$maint" ]; then
    echo "Dropping to a maintenance shell, as requested. Good luck!"
    echo
    bash
fi

# NOTE: Inside initramfs, prior to switch_root, if $init is a symlink w/
#       absolute path, it will be broken...
init_check=/sysroot$init
if [ -L $init_check -a $(readlink $init_check | head -c1) != "." ]; then
    init_check=/sysroot$(readlink $init_check)
fi
if [ ! -x $init_check ]; then
    echo "---------------------------------------------------------"
    echo "WARNING: Requested $init binary does not exist on rootfs."
    echo "---------------------------------------------------------"
    echo
    echo "Dropping to a shell. Good luck!"
    echo
    bash
fi

# Leave initramfs and transition to rootfs
#
# FIXME: mdmon?
#
kill `pidof udevd`

decho "switching to real rootfs..."
go="exec switch_root /sysroot $init $initargs"
decho $go
eval $go


echo "---------------------------------"
echo "WARNING: Error switching to real rootfs!"
echo "---------------------------------"
echo
echo "Dropping to a shell. Good luck!"
echo
bash
